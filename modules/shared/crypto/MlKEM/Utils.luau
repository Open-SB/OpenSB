--[=[
	ML-KEM Utilities Module
	
	Utility functions for ML-KEM implementation
	
	Example usage:
		local Utils = require(script.Utils)
		local IsEqual = Utils.CtMemcmp(Buffer1, Buffer2)
		
		Utils.CtCondMemcpy(Condition, Dest, Src1, Src2)
		
		local PubKeySize = Utils.GetKemPublicKeyLen(4) -- 1568 bytes
		local SecKeySize = Utils.GetKemSecretKeyLen(4) -- 3168 bytes
--]=]

--!strict
--!optimize 2
--!native

local MlKemParams = require("./Params")

local Utils = {}

function Utils.CtMemcmp(Bytes0: buffer, Bytes1: buffer): number
	local Len0 = buffer.len(Bytes0)
	local Len1 = buffer.len(Bytes1)

	if Len0 ~= Len1 then
		return 0x00000000
	end

	local Diff = 0
	local Len4 = Len0 - (Len0 % 4)

	for Index = 0, Len4 - 4, 4 do
		local Word0 = buffer.readu32(Bytes0, Index)
		local Word1 = buffer.readu32(Bytes1, Index)
		Diff = bit32.bor(Diff, bit32.bxor(Word0, Word1))
	end

	for Index = Len4, Len0 - 1 do
		local Byte0 = buffer.readu8(Bytes0, Index)
		local Byte1 = buffer.readu8(Bytes1, Index)
		Diff = bit32.bor(Diff, bit32.bxor(Byte0, Byte1))
	end

	return if Diff == 0 then 0xFFFFFFFF else 0x00000000
end

function Utils.CtSelect(Cond: number, A: number, B: number): number
	local Mask = bit32.band(Cond, 0xFFFFFFFF)

	return bit32.bor(bit32.band(A, Mask), bit32.band(B, bit32.bnot(Mask)))
end

function Utils.CtCondMemcpy(Cond: number, Sink: buffer, Source0: buffer, Source1: buffer)
	local SinkLen = buffer.len(Sink)
	local Mask = bit32.band(Cond, 0xFFFFFFFF)
	local InvMask = bit32.bnot(Mask)
	local Len4 = SinkLen - (SinkLen % 4)

	for Index = 0, Len4 - 4, 4 do
		local Word0 = buffer.readu32(Source0, Index)
		local Word1 = buffer.readu32(Source1, Index)
		local Selected = bit32.bor(bit32.band(Word0, Mask), bit32.band(Word1, InvMask))
		buffer.writeu32(Sink, Index, Selected)
	end

	for Index = Len4, SinkLen - 1 do
		local Byte0 = buffer.readu8(Source0, Index)
		local Byte1 = buffer.readu8(Source1, Index)
		local Selected = bit32.bor(bit32.band(Byte0, Mask), bit32.band(Byte1, InvMask))
		buffer.writeu8(Sink, Index, Selected)
	end
end

function Utils.BitReverse(Value: number, BitWidth: number): number
	local Reversed = 0
	for I = 0, BitWidth - 1 do
		local Bit = bit32.band(bit32.rshift(Value, I), 1)
		Reversed = bit32.bor(Reversed, bit32.lshift(Bit, BitWidth - 1 - I))
	end

	return Reversed
end

function Utils.GetPkePublicKeyLen(K: number): number
	if not MlKemParams.CheckK(K) then
		error("Invalid K parameter")
	end

	return K * 12 * 32 + 32
end

function Utils.GetPkeSecretKeyLen(K: number): number
	if not MlKemParams.CheckK(K) then
		error("Invalid K parameter")
	end

	return K * 12 * 32
end

function Utils.GetPkeCipherTextLen(K: number, Du: number, Dv: number): number
	if not MlKemParams.CheckK(K) then
		error("Invalid K parameter")
	end
	if not MlKemParams.CheckD(Du) then
		error("Invalid Du parameter")
	end
	if not MlKemParams.CheckD(Dv) then
		error("Invalid Dv parameter")
	end

	return 32 * (K * Du + Dv)
end

function Utils.GetKemPublicKeyLen(K: number): number
	return Utils.GetPkePublicKeyLen(K)
end

function Utils.GetKemSecretKeyLen(K: number): number
	if not MlKemParams.CheckK(K) then
		error("Invalid K parameter")
	end

	return Utils.GetPkeSecretKeyLen(K) + Utils.GetPkePublicKeyLen(K) + 32 + 32
end

function Utils.GetKemCipherTextLen(K: number, Du: number, Dv: number): number
	return Utils.GetPkeCipherTextLen(K, Du, Dv)
end

return Utils
